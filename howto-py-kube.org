#+TITLE: HOWTO Run Python in Kubernetes
#+AUTHOR: Allen Gooch
#+EMAIL: allen.gooch@gmail.com
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LANGUAGE: en
#+STARTUP: overview

* Overview
  
 This document is a guide to running [[https://www.python.org/][Python]] apps in a [[https://kubernetes.io/][Kubernetes]] environment.

 This guide is intended to demo:
 - creating a local kubernetes cluster to deploy to
 - creating a demo web service to deploy to cluster
 - building the demo web service image
 - deploying the demo web service to cluster
 - scaling the deployment of the demo web service
 - updating the deployment of the demo web service
 - creating delarative deployment specifications for demo web service
 - managing deployments of the demo web service

 Note that this guide demos commands on macOS, but is still valid for other 
 operating systems, apart from the macOS tools installation instructions.

* Usage

 Open up a terminal for the demo.  Everything we do will be done in a shell.
 I personally use [[http://www.zsh.org/][zsh]] with [[https://github.com/sorin-ionescu/prezto][prezto]] but vanilla bash will perform just as well.

 The first thing to do is clone this repository.

#+NAME: clone_repo
#+BEGIN_SRC sh
mkdir -p tmp && cd tmp
git clone https://github.com/mojochao/howto-py-kube.git
#+END_SRC

 Next remove the cloned git repository and initialize a new one so we can
 capture the state of the system we're building at various points in time.

#+NAME: init_repo
#+BEGIN_SRC sh :tangle scripts/init_demo_repo.sh
rm -rf .git
git init
head -n 5 .gitignore > .gitignore  # don't ignore app directory
git add .gitignore
git commit -m 'Initial commit'
git tag -a new-repo 
#+END_SRC

 Open this document in your editor of choice.  Mine is [[http://spacemacs.org/][spacemacs]], a community
 curated configuration of the [[https://www.gnu.org/software/emacs/][Emacs]] editor, with the [[http://spacemacs.org/layers/+emacs/org/README.html][Org layer]] added to my
 [[https://github.com/mojochao/dotfiles/blob/master/src/.spacemacs][.spacemacs]] config file. 

 This document is an example of [[http://howardism.org/Technical/Emacs/literate-devops.html][Literate DevOps]], a term coined by the awesome 
 emacs hacker [[http://www.howardism.org/][Howard Abrams]]. 

 Emacs [[https://orgmode.org][Org mode]] provides capabilities for interactively using this document 
 /The Right Way (tm)/.  After opening this file in emacs, type =C-c C-c= in a 
 source block to execute the source.

 For those not down with [[http://www.howardism.org/Technical/Emacs/tao-of-emacs.html][The Tao of Emacs]] you will have to manually enter the 
 demonstrated commands.

 [[https://orgmode.org][Org mode]] also provides the ability to extract document source blocks into 
 scripts.

#+NAME: export_scripts
#+BEGIN_SRC elisp :results output
(make-directory "scripts" t)
(org-babel-tangle-file "howto-py-kube.org")
#+END_SRC

 Once generated, these scripts can be used to perform the commands demonstrated
 in this document.

 [[https://orgmode.org][Org mode]] also provides the ability to export documents in multiple formats.

 The most commonly used is HTML.

#+NAME: export_html
#+BEGIN_SRC elisp
(org-html-export-to-html "howto-py-kube.org")
#+END_SRC

 Another commonly used format is PDF.

#+NAME: export_pdf
#+BEGIN_SRC elisp
(org-latex-export-to-pdf "howto-py-kube.org")
#+END_SRC

 If not viewing in emacs, you can also use the HTML rendered version on its 
 [[https://github.com/mojochao/howto-py-kube][GitHub project]] page. 

* Create local kubernetes cluster
  
 Note that [[https://brew.sh/][Homebrew]] is used for installing packages on macOS.  Ensure it is
 installed before proceeding.

 A [[https://www.docker.com/docker][Docker]] environment is used to run images in containers. Ensure it is 
 installed.  

#+BEGIN_SRC sh :tangle scripts/create_kubes_macos.sh
which docker || brew cask install docker
#+END_SRC

 After install, =Docker.app= will be running and you will see the Docker Whale 
 icon in your Menu Bar.
  
 It is not required to have the =Docker.app= application running, as minikube
 will run the docker machine itself.  Feel free to quit =Docker.app= at any 
 time.

 The [[https://kubernetes.io/docs/reference/kubectl/overview][kubectl]] command is used to manage the Kubernetes cluster at the lowest
 level.  Ensure it is installed.

#+BEGIN_SRC sh :tangle scripts/create_kubes_macos.sh
which kubectl || brew install kubectl
#+END_SRC

 The [[https://docs.helm.sh/helm][helm]] command is used to manage deployments to the Kubernetes cluster at a
 high level.  Ensure it is installed.

#+BEGIN_SRC sh :tangle scripts/create_kubes_macos.sh
which helm || brew install kubernetes-helm
#+END_SRC

 [[https://kubernetes.io/docs/getting-started-guides/minikube/][Minikube]] is used to provide the local Kubernetes cluster.  Ensure it is 
 installed.

#+BEGIN_SRC sh :tangle scripts/create_kubes_macos.sh
which minikube || brew cask install minikube
#+END_SRC

 Minikube needs a VM driver for the host OS.  On macOS, [[https://github.com/kubernetes/minikube/blob/master/docs/drivers.md#hyperkit-driver][hyperkit]] is the 
 recommended driver.  Install it.

#+BEGIN_SRC sh :tangle scripts/create_kubes_macos.sh
curl -LO https://storage.googleapis.com/minikube/releases/latest/docker-machine-driver-hyperkit \
&& chmod +x docker-machine-driver-hyperkit \
&& sudo mv docker-machine-driver-hyperkit /usr/local/bin/ \
&& sudo chown root:wheel /usr/local/bin/docker-machine-driver-hyperkit \
&& sudo chmod u+s /usr/local/bin/docker-machine-driver-hyperkit
#+END_SRC

 If not using macOS, consult the [[https://github.com/kubernetes/minikube/blob/master/docs/drivers.md][driver plugin installation]] docs for options.

 Start a minikube cluster with the hyperkit vm driver on macOS.

#+BEGIN_SRC sh :tangle scripts/create_kubes_macos.sh
minikube start --vm-driver=hyperkit
#+END_SRC

 Query the minikube cluster status with the =minikube status= command.

#+BEGIN_SRC sh :tangle scripts/create_kubes_macos.sh
minikube status
#+END_SRC

 The output indicates that the =kubectl= command has had its context set to the
 address of the minikube cluster.

 Use the =kubectl cluster-info= command to confirm this.

#+BEGIN_SRC sh :tangle scripts/create_kubes_macos.sh
kubectl cluster-info
#+END_SRC

 Open the cluster dashboard.

#+BEGIN_SRC sh
minikube dashboard
#+END_SRC

 Leave the dashboard open so we can easily observe changes to the cluster.

 Congratulations!  You're the owner of a brand new local kubernetes cluster.

* Create the demo service

 We now need a workload to run on the cluster.

 Start by creating a directory for the demo web service.

#+BEGIN_SRC sh :tangle scripts/create_app.sh 
mkdir app
#+END_SRC

 Add the demo web service source code.

#+BEGIN_SRC sh :tangle scripts/create_app.sh 
cat <<EOF > app/app.py
import os
from bottle import route, run

@route('/')
def greet():
    return 'Hello World from {host}'.format(host=os.uname()[1])

if __name__ == '__main__':
    host = '0.0.0.0'
    port = 8080
    print('starting greet service on {}:{}'.format(host, port))
    run(host=host, port=port, debug=True)
EOF
#+END_SRC

 We also need a requirements file for the app.

#+BEGIN_SRC sh :tangle scripts/create_app.sh
cat <<EOF > app/requirements.txt
bottle
EOF
#+END_SRC

 The last thing we need is a Dockerfile.

#+BEGIN_SRC sh :tangle scripts/create_app.sh 
cat <<EOF > app/Dockerfile
FROM python:3.6-alpine
EXPOSE 8080
COPY . /app
WORKDIR /app
RUN pip install -r requirements.txt
ENTRYPOINT ["python", "app.py"]
EOF
#+END_SRC

 Done!  That's all we need to provide the demo web service.

* Build and run the demo service in docker
  
 Now that we have an app ready to build, let's do that.  Time to give it a name.
 Let's call this app =greet-api=.

#+BEGIN_SRC sh
docker build -t greet-api app
#+END_SRC

 It will now be present in the images.

#+BEGIN_SRC sh
docker images
#+END_SRC

 Let's run the image in a docker container.

#+BEGIN_SRC sh
docker run --name greet-container --rm -d -p 8080:8080 greet-api
#+END_SRC

 It will now be present in the list of running containers.

#+BEGIN_SRC sh
docker ps
#+END_SRC

 Finally, let's test the service at the exposed port.

#+BEGIN_SRC sh
curl -s localhost:8080
#+END_SRC

 It's alive!  

 We can run a shell inside the container to poke around.

#+BEGIN_SRC sh
docker exec -it greet-container bash
#+END_SRC

 Now that we've seen it works, kill it.

#+BEGIN_SRC sh
docker kill $(docker ps -aqf "name=greet-container")
#+END_SRC

 It will no longer be present in the list of running containers.

#+BEGIN_SRC sh
docker ps
#+END_SRC

 Remove the build image as well.

#+BEGIN_SRC sh
docker rmi greet-api
#+END_SRC

 It will no longer be present in the images.

#+BEGIN_SRC sh
docker images
#+END_SRC

 Now you've seen the full lifecycle of a docker image and container.

* Build and run the demo service in minikube
 
 Building for minikube means setting the docker engine to the one running inside
 the cluster.

 When you wish docker to use the minikube docker env, you can do this in a shell
 session.

#+BEGIN_SRC sh
eval $(minikube docker-env)
#+END_SRC

 When you no longer wish docker to use the minikube docker env, you can do 
 the same passing the =-u= option for uninstall.

#+BEGIN_SRC sh
eval $(minikube docker-env -u)
#+END_SRC

 Note that all =docker= commands below will demonstrate setting the minikube
 docker environment, as each source block is effectively a different shell
 session.  In practice, you would probably only do it at the beginning of your
 shell session.

 Now that we know how to configure docker to use minikube, we can buld our app
 image for the cluster.  This time let's build it with the =v1= tag.

#+BEGIN_SRC sh
eval $(minikube docker-env) && docker build -t greet-api:v1 app
#+END_SRC

 Let's run the image in the cluster.
 
#+BEGIN_SRC sh
kubectl run greet --image=greet-api:v1 --port=8080 --generator=run/v1
#+END_SRC

 The =--image= argument specifies the container image we want to run, and the
 =--port= option tells Kubernetes that our app is listening on port 8080.

 The =--generator= option is something that we will not typically use, as we
 will typically provide specs describing the Kubernetes resources we are using.
 This is just a shortcut for getting a workload running quickly.

 If you now look at your dashboard you will see a [[https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/][replication controller]] and a
 [[https://kubernetes.io/docs/concepts/workloads/pods/pod/][pod]] resource created.

 The created pod is not directly accessible to the outside world.  To enable 
 that we need to expose it as a load balanced service.

#+BEGIN_SRC sh
kubectl expose rc greet --type=LoadBalancer --name greet-http
#+END_SRC 

 If you look again at your dashboard you will see a [[https://kubernetes.io/docs/concepts/services-networking/service/][service]] resource created.

 Now we should be able to access it once we get its external IP address.

#+BEGIN_SRC sh
kubectl get svc 
#+END_SRC

 In a non-minikube cluster, the external IP address of the =greet-http= service
 would be displayed once established.  Notice that it says =<pending>=.  

 Since minikube is a single host, it doesn’t support LoadBalancer services, so
 the service will never get an external IP.  We can still access the service 
 through its external port, but we need to ask minikube for it.

#+BEGIN_SRC sh
minikube service greet-http --url
#+END_SRC

 Finally, let's test the service at the exposed port.

#+BEGIN_SRC sh
curl -s $(minikube service greet-http --url)
#+END_SRC

 It's alive!  

* Deploy the demo service

* Scale the demo service

* Update the demo service

* Describe demo service deployments

* Manage demo service deployments
* Clean up
 
 We should clean up after ourselves.

#+NAME: clean_repo
#+BEGIN_SRC sh :tangle scripts/clean_repo.sh
rm -rf app scripts
rm -f *.html *.pdf *.tex
#+END_SRC

 And with that, we're done.  I hope you learned something.  I know I did.

